# 汇编语言程序设计

计算机的硬件组成结构

CPU：运算器，控制器，寄存器

主存储器

I/O接口

汇编语言抽象成为：寄存器，存储器地址和输入输出地址



## 寄存器（Register）

* 处理器内部的告诉存储单元

* 用于暂时存放执行过程中的代码和数据

* 透明寄存器：对应用人员不可见，不可用编程直接控制

* 可编程寄存器：有引用名称

* * 通用寄存器
  * 专用寄存器

  

| 通用寄存器                           | 专用寄存器                            |
| ------------------------------------ | ------------------------------------- |
| 16位：AX、BX、CX、DX、SI、DI、BP、SP | 标志寄存器FLAGS<br/>指令指针寄存器EIP |
| 8位：AH、AL、BH、BL、CH、CL、DH、DL  | 段寄存器：CS、DS、SS、ES、FS、GS      |



### 通用寄存器

* 处理器最常使用的整数通用寄存器
* 可用于保存整数数据、地址等

 <img src=".\img\{94C58A26-CC0B-C8B2-95D4-A5512BF5AFE9}.png" width = "200" height = "200" div align="center" />





| AX   | 累加器         | Accumulator       |
| ---- | -------------- | ----------------- |
| BX   | 基址寄存器     | Base Address      |
| CX   | 计数器         | Counter           |
| DX   | 数据存储器     | Data              |
| SI   | 源变址寄存器   | Source Index      |
| DI   | 目的变址寄存器 | Destination Index |
| BP   | 基址指针       | Base Pointer      |
| SP   | 堆栈指针       | Stack Pointer     |

 

### 处理器专用寄存

#### 标志Flag

* 标志体现了某种工作形态
* 有些处理器标志用以反映指令执行结果
* * 加减是否借位，数据是否为零，或者是正或负

* 有些处理器标志用于控制指令执行形式
* * 处理器是否单步操作、是否影响外部中断
* 设计一个或多个二进制表示一种标志
* 用0和1的组合表达标志的不同状态



##### 处理器最基本的标志：状态标志

* 用于记录指令执行结果的辅助星系
* 加减运算和逻辑运算指令主要设计他们
* 其他指令的执行也会相应的设置他们
* 处理器主要使用其中5个构成各种条件
* * 分支指令判断这些条件实现程序分支



#### 指令指针寄存器IP

保存将要**执行的指令在主存的存储器地址**

* 顺序执行时自动增量（加上该指令的字节数），**指向下一条指令**
* 分支、调用等操作时执行控制转移指令修改，引起程序转移到指定的指令执行
* 出现中断或异常时被处理器赋值而相应改变

保存一个特定用途的内容，一条指令

改变以改变指令执行的顺序

### 存储空间分段管理

“段”是保存相关代码或数据的一个主存区域

应用程序主要分3类基本段

| 主存空间                 |                                              |
| ------------------------ | -------------------------------------------- |
| 代码段(Code Segment) CS  | 存放程序的可执行代码（处理器指令）           |
| 数据段(Data Segment) DS  | 存放程序所用的数据，eg：全局变量             |
| 堆栈段(Stack Segment) SS | 程序需要的特殊区域，存放返回地址、临时变量等 |

段的说明开始——段寄存器，某个段在主存的位置

#### 段寄存器

表明某个段在主存中的位置

CS、SS、DS、ES



#### 代码段的当前指令地址

**代码段**

* 段基地址：代码段寄存器CS指示
* 偏移地址：指令指针偏移地址IP保存

存储器地址在编程时，是以逻辑地址形式访问

逻辑地址-> 段基地址：偏移地址

CS段基地址指明了代码段的开始

IP保存的偏移地址，明确指明正在执行的段内的哪个指令

组合指明当前指令地址

<img src="./img\{A3EC608F-28F5-3F97-FFDC-810F397D50C9}.png" width = "200" height = "200" div align=left />



####   堆栈段的当前栈顶地址

**堆栈段**

* 段基地址：堆栈段寄存器SS指示
* 偏移地址：堆栈指针寄存器SP保存

<img src="./img\{812CD6D1-F099-932C-62EC-0CB1A950C462}.png" width = "200" height = "200" div align=left />



#### 数据段的操作数地址

**数据段**

* 段基地址：数据段寄存器DS指示，有时也可ES、FS、GS指示
* 偏移地址：存储器寻址方式计算出有效地址EA指示



## 存储器组织

被抽象为存储器地址

### 存储器地址

主存储器容量很大、被划分为许多存储单元

每个存储单元被编排一个号码、即存储单元地址

* 称为存储器地址

每个存储单元以字节为基本存储单位

* 字节编址（Byte Addressable）
* 一个字节=八个二进制位：1Byte=8Bit

数据的基本单位：位、字节、字、双字

### 存储器的物理地址

处理器连接的物理存储器使用物理地址

* 从0开始
* 直到其支持的最大存储单元

#### 存储模型

程序并不直接寻址物理存储器，会对存储器的管理有麻烦

MMU存储管理单元，存储模型，用于程序访问存储器

### 逻辑地址

存储器空间可以分段管理，采用逻辑地址指示

* 逻辑地址=段基地址：偏移地址
* * 段基地址=在主存中的起始位置
  * 偏移地址=距离段基地址的位移量
* 处理器内部以及编程时采用逻辑地址

物理地址是唯一的，而逻辑地址可以多个



## 处理器指令

指令由操作码和操作数组成

* 操作码表明处理器执行的操作
* * 数据传送、加法、跳转等
  * 指令注记符表示
* 操作数是参与操作的数据对象
* * 主要以寄存器名或地址形式指明数据的来源
  * 使用寄存器、常量、变量等形式表示

### MOV

传送指定：`MOV`

将数据从一个位置传送到另一个位置，类似高级语言的赋值语句

```assembly
mov dest,src ;dest<-src
;目的操作数dest：数据将要传送到的位置；源操作数src：被传送的数据或数据所在的位置
mov ax,100 ;AX<-100(常量)
mov ax dvar;AX<-dvar(变量)
mov ax bx ;AX<-bx(寄存器)
```

给定的是操作数的位置，实际传输的操作数位置的数据



## 语句格式

源程序由语句组成

* 执行性语句：表达处理器指令、实现功能：赋值，分支，完成一个功能

  标号：	硬指令助记符	操作数，操作数 ;注释

* 说明性语句：表达伪指令、控制汇编方式：变量的定义，类型的说明

  名字：	伪指令助记符	参数，参数，..；注释.



### 标号与名字

* 标号

  冒号分隔

  表示处理器指令在主存中的逻辑地址

  表示分支、循环等程序的目的地址

* 名字

  空格或制表符分隔

  变量名，段名，子程序名

  反映变量、段和子程序等的逻辑地址

都是用户定义的标识符



### 助记符

* 助记符帮助记忆指令功能的符号

  硬指令助记符表示处理器指令

  伪指令助记符表示一个汇编命令

* 处理器指令：传送指令MOV

* 伪指令：字节变量定义

  助记符：BYTE（DB）

  功能：在主存占用若干存储空间，用于保存变量值

```assembly
msg byte 'Hello,Assembly!',13,10,0
```



### 操作数和参数

* 处理器指令的操作数：表示参与操作的对象

  具体的常量

  保存在寄存器的数据

  保存在存储器的变量

  dest和src

* 伪指令的参数

  常量、变量名、表达式等

  可以多个，参数之间以逗号分隔

```assembly
msg byte 'Hello,Assembly!',13,10,0;字符串是操作数,后面是参数，定义字符串
mov ax, offset msg;ax获得msg的偏移地址
```

### 注释

分号后的内容



## 源程序框架

数据段、代码段等的定义

程序起始执行的位置

汇编结束的指示

MASM

```assembly
	.data	;定义数据段
	...		;数据定义
	.code	;定义代码段
start:		;程序执行起始位置
	...		;主程序
	exit 0	;程序正常执行结束
	...		;子程序
	end start	;汇编结束
```

### INCLUDE包含伪指令

用于声明常用的常量定义，过程说明，共享的子程序库等，相当于C语言头文件

### 段的简化定义

```assembly
;数据段定义伪指令
.data	;创建一个数据段
;代码段定义伪指令
.code	;创建一个代码段
;堆栈段定义伪指令
.stack	;创建一个堆栈段，window自动维护，不用设置
```

### 程序的开始和结束

* 程序开始执行的位置

  使用一个标号（eg：START）

  作为汇编结束`END`伪指令的参数

* 应用程序执行终止

  语句`EXIT 0`终止程序执行

  返回操作系统，并提供一个返回代码0

* 源程序汇编结束

  使用`END`伪指令语句

```assembly
start:		;程序执行起始位置
	...		;主程序
	exit 0	;程序正常执行结束
	...		;子程序
	end start	;汇编结束
```

执行终止不等于汇编结束

end是结束start

程序结束的意思是把控制权交还给操作系统

汇编结束是源程序到此结束

框架可作为模板文件



## 信息显示程序

### 信息显示

```assembly
	;在数据段给出这个字符串形式的信息
	.data	
msg byte 'Hello,Assembly!',13,10,0	;13,10表示'\n'	
	;0表示字符串的结尾（高级语言自动有）	定义要显示的字符串
	;在代码段编写要显示字符串的程序
	.code
start:
	mov ax, offset msg	;指定字符串的偏移地址，ax寄存器，显示的入口参数存放的地方
	call dispmsg	;调用子程序显示信息
	exit 0
	end start
```





## 常量表达

常量是一个确定的数值，可直接编码于指令代码中，不是保存在存储器中可变的便令啊

支持的多种常量表达形式

* 常数：直接给出数值
* 字符和字符串：ASCII
* 符号常量
* 数值表达式

符号名 `equ` <字符串>

数值表达式

加减乘除

数值作为地址，数值表达式成为地址表达式

* 地址表达式只能使用加减

* 指示地址移动常量表示的若干个字节存储单元

  地址+常量

  地址-常量

| 算术表达式 | 67h-52h |
| ---------- | ------- |
| 地址表达式 | var+4   |

### 数据表达程序

```assembly
const1 byte 100,100d,01100100b,64h,'d';不同进制和形式表达了同一个数值，机器指令中都是二进制
;.00000000 64 64 64 64 64
mov ax,offset const1	;从const1开始显示
call dispmsg
```



0DH回车，0AH换行

数字0用于字符串的结尾



## 变量定义

变量

* 随程序运行会发生变化的数据
* 保存在可读写的主存空间

变量的实质是主存单元的数据，因而可以改变

* 变量需要先定义才能使用
* 变量具有属性方便应用

变量表达主存数据，即存储器操作数，一般在程序的数据段中



### 变量的定义

变量名	变量定义伪指令	初值表

变量名：用户起的标识符，表示首元素的**逻辑地址**

变量定义伪指令，byte，word，dw，db等表示**变量类型**

变量初值表是用逗号分隔的一个或多个参数，表示**变量初值**，相当于高级语言的数组

**主要的变量定义伪指令**

| BYTE：字节  | 分配一个或多个字节单元，每个数据是8位、字节量  | char  |
| ----------- | ---------------------------------------------- | ----- |
| WORD：字    | 分配一个或多个字单元，每个数据是16位、字量     | short |
| DWORD：双字 | 分配一个或多个双字单元，每个数据是32位、双字量 | long  |

#### 变量定义的初值表

变量定义是申请存储空间

* 同时还可以进行存储单元初始化
* 即用初值表赋予变量初值

初值表可以有一个或多个参数，多个参数用逗号分隔

* 各种形式的常量

* 使用"?"表示初值不确定，即未赋初值

* 使用复制操作符`DUP`表示多个相同数值

  格式：重复次数	DUP(重复参数)



变量定义之后

* 分配了存储空间
* 赋予了初值（也可不）
* 创建了变量名，可以获知变量的地址和类型

### 八位字节变量定义

* 8位无符号整数0~255
* 8位补码表示有符号整数：-128~+127
* 一个字符（ASCII）
* 压缩BCD：0~99
* 非压缩：0~9

**定义字符串要使用字节变量定义BYTE**

```assembly
msg byte 'Hello',13,10,0
const1 byte 100,64h,'d'
const6 byte 4*4,34h+24
bvar byte ?;表示初值不定，一般用0填充
bvar1 byte 5 dup('$');重复五个
```

可以用变量名来访问首元素，然后偏移地址来访问后面的元素



### 十六位字变量定义

* 16位无符号整数：0~65535
* 16位补码表示的有符号整数：-32768~+32767
* 16位段地址
* 16位偏移地址

```assembly
wvar1 word 0,-32768,65535;每一个值都是字类型，两个字节
wvar2 word ?
minint = 10
wvar3 word 5 dup(minint)
```

* 16位变量定义，使用word伪指令，每个数据是一个字量，占用两个存储单元
* 变量定义的参数可以是有符号数，也可是无符号数

### 三十二位双字变量定义

除了一些数字的表达，还有就是32位逻辑地址（含十六位段地址和十六位偏移地址）

 