

# 汇编语言程序设计

计算机的硬件组成结构

CPU：运算器，控制器，寄存器

主存储器

I/O接口

汇编语言抽象成为：寄存器，存储器地址和输入输出地址



## 寄存器（Register）

* 处理器内部的高速存储单元

* 用于暂时存放执行过程中的代码和数据

* 透明寄存器：对应用人员不可见，不可用编程直接控制

* 可编程寄存器：有引用名称

  * 通用寄存器
  * 专用寄存器

  

| 通用寄存器                           | 专用寄存器                            |
| ------------------------------------ | ------------------------------------- |
| 16位：AX、BX、CX、DX、SI、DI、BP、SP | 标志寄存器FLAGS<br/>指令指针寄存器EIP |
| 8位：AH、AL、BH、BL、CH、CL、DH、DL  | 段寄存器：CS、DS、SS、ES、FS、GS      |



### 通用寄存器

* 处理器最常使用的整数通用寄存器
* 可用于保存整数数据、地址等

 <img src=".\img\{94C58A26-CC0B-C8B2-95D4-A5512BF5AFE9}.png" width = "200" height = "200" div align="center" />





| 名称 |                |                   | 作用                                                         |
| ---- | -------------- | ----------------- | ------------------------------------------------------------ |
| AX   | 累加器         | Accumulator       | 使用频率最高，用于算术，逻辑运算，以及与外设传送信息，比如一些显示的接口 |
| BX   | 基址寄存器     | Base Address      | 常用作存放存储器地址                                         |
| CX   | 计数器         | Counter           | 作为循环和串操作等指令中的隐含计数器                         |
| DX   | 数据存储器     | Data              | 用于存放双字长数据的高16位，或存放外设端口地址               |
| SI   | 源变址寄存器   | Source Index      | 常用于存储器寻址时提供地址                                   |
| DI   | 目的变址寄存器 | Destination Index |                                                              |
| BP   | 基址指针       | Base Pointer      | 表示数据在堆栈段中的基地址                                   |
| SP   | 堆栈指针       | Stack Pointer     | 堆栈指针寄存器，表示栈顶的偏移地址，专用的                   |

 

### 处理器专用寄存

#### 标志Flag

* 标志体现了某种工作形态
* 有些处理器标志用以**反映指令执行结果**
  * 加减是否借位，数据是否为零，或者是正或负

* 有些处理器标志用于控制指令执行形式
  * 处理器是否单步操作、是否影响外部中断
* 设计一个或多个二进制表示一种标志
* 用0和1的组合表达标志的不同状态



##### 处理器最基本的标志：状态标志

* 用于记录指令执行结果的辅助
* 加减运算和逻辑运算指令主要设计他们
* 其他指令的执行也会相应的设置他们
* 处理器主要使用其中5个构成各种条件
  * 分支指令判断这些条件实现程序分支



#### 指令指针寄存器IP（专用寄存器）

指示代码段中指令的偏移地址

与代码段寄存器CS联用，确定下一条指令的物理地址

通过`CS:IP`寄存器来控制指令序列的执行流程



保存将要**执行的指令在主存的存储器地址**

* 顺序执行时自动增量（加上该指令的字节数），**指向下一条指令**
* 分支、调用等操作时执行控制转移指令修改，引起程序转移到指定的指令执行
* 出现中断或异常时被处理器赋值而相应改变

保存一个特定用途的内容，一条指令

改变以改变指令执行的顺序

### 存储空间分段管理

“段”是保存相关代码或数据的一个主存区域

应用程序主要分3类基本段

| 主存空间                 |                                              |
| ------------------------ | -------------------------------------------- |
| 代码段(Code Segment) CS  | 存放程序的可执行代码（处理器指令）           |
| 数据段(Data Segment) DS  | 存放程序所用的数据，eg：全局变量             |
| 堆栈段(Stack Segment) SS | 程序需要的特殊区域，存放返回地址、临时变量等 |

段的说明开始——段寄存器，某个段在主存的位置

#### 段寄存器

4个16位段寄存器，每个段寄存器确定一个逻辑段的起始地址

| 段寄存器 | 作用                 |
| -------- | -------------------- |
| CS       | 指明代码段的起始地址 |
| SS       | 指明堆栈段的起始地址 |
| DS       | 指明数据段的起始地址 |
| ES       | 指明附加段的起始地址 |

CS、SS、DS、ES



#### 代码段的当前指令地址

**代码段**

* 段基地址：代码段寄存器CS指示
* 偏移地址：指令指针偏移地址IP保存

存储器地址在编程时，是以逻辑地址形式访问

逻辑地址-> 段基地址：偏移地址

CS段基地址指明了代码段的开始

IP保存的偏移地址，明确指明正在执行的段内的哪个指令

组合指明当前指令地址

处理器利用`CS:IP`取得下一条要执行的指令

<img src="./img\{A3EC608F-28F5-3F97-FFDC-810F397D50C9}.png" width = "200" height = "200" div align=left />



####   堆栈段的当前栈顶地址

**堆栈段**

* 段基地址：堆栈段寄存器SS指示
* 偏移地址：堆栈指针寄存器SP保存

<img src="./img\{812CD6D1-F099-932C-62EC-0CB1A950C462}.png" width = "200" height = "200" div align=left />

处理器利用`SS:SP`操作堆栈顶的数据



#### 数据段的操作数地址

**数据段**

* 段基地址：数据段寄存器DS指示
* 偏移地址：存储器寻址方式计算出有效地址EA指示

处理器利用`DS:EA `存取数据段中的数据



#### 附加段的存放

附加段是附加的数据段

附加段寄存器ES存放附加段的段地址

各种主存寻址方式得到存储器中操作数的偏移地址

处理器利用`ES:EA`获取附加段的数据

串操作指令将附加段作为其目的操作数的存放区域



## 存储器

被抽象为存储器地址

存储器是由大量存储单元组成，需要用编号区别每个单元，编号=地址

### 存储器地址

主存储器容量很大、被划分为许多存储单元

每个存储单元被编排一个号码、即存储单元地址

* 称为存储器地址

**每个存储单元以字节为基本存储单位**

* 字节编址（Byte Addressable）
* 一个字节=八个二进制位：1Byte=8Bit

数据的基本单位：位、字节、字、双字

### 存储器的物理地址

处理器连接的物理存储器使用物理地址

* 从0开始
* 直到其支持的最大存储单元

#### 存储模型

程序并不直接寻址物理存储器，会对存储器的管理有麻烦

MMU存储管理单元，存储模型，用于程序访问存储器

### 逻辑地址

存储器空间可以分段管理，采用逻辑地址指示

* 逻辑地址=段基地址：偏移地址
  * 段基地址=在主存中的起始位置
  * 偏移地址=距离段基地址的位移量
* 处理器内部以及编程时采用逻辑地址

物理地址是唯一的，而逻辑地址可以多个

`段基地址:段内偏移地址`





## BCD码

二进制编码的十进制数

* 一个十进制数位0~9用4为二进制编码表示

直观表示

0100 1001 0111 1000.0001 0100 1001

真值：4978.149



## 处理器指令

指令由操作码和操作数组成

* 操作码表明处理器执行的操作
  * 数据传送、加法、跳转等
  * 指令注记符表示
* 操作数是参与操作的数据对象
  * 主要以寄存器名或地址形式指明数据的来源
  * 使用寄存器、常量、变量等形式表示

### MOV

传送指定：`MOV`

将数据从一个位置传送到另一个位置，类似高级语言的赋值语句

```assembly
mov dest,src ;dest<-src
;目的操作数dest：数据将要传送到的位置；源操作数src：被传送的数据或数据所在的位置
mov ax,100 ;AX<-100(常量)
mov ax dvar;AX<-dvar(变量)
mov ax bx ;AX<-bx(寄存器)
```

给定的是操作数的位置，实际传输的操作数位置的数据



## 语句格式

源程序由语句组成

* 执行性语句：表达处理器指令、实现功能：赋值，分支，完成一个功能

  标号：	硬指令助记符	操作数，操作数 ;注释

* 说明性语句：表达伪指令、控制汇编方式：变量的定义，类型的说明

  名字：	伪指令助记符	参数，参数，..；注释.



### 标号与名字

* 标号

  冒号分隔

  **表示处理器指令在主存中的逻辑地址**

  **表示分支、循环等程序的目的地址**

  反映应指令位置(逻辑地址)的标识符

* 名字

  空格或制表符分隔

  变量名，段名，子程序名

  反映变量、段和子程序等的逻辑地址
  
  伪指令位置
  
* 标识符

都是用户定义的标识符

* 保留字

  汇编程序中已经利用的标识符:

  * 硬指令助记符——MOV、ADD
  * 伪指令助记符——DB、EQU
  * 操作符——OFFSET、PTR
  * 寄存器名——AX、CS
  * 预定义符号——@data

### 助记符

* 助记符帮助记忆指令功能的符号

  硬指令助记符表示处理器指令

  伪指令助记符表示一个汇编命令

* 处理器指令：传送指令MOV

* 伪指令：字节变量定义

  助记符：BYTE（DB）

  功能：在主存占用若干存储空间，用于保存变量值

```assembly
msg byte 'Hello,Assembly!',13,10,0
```



### 操作数和参数

* 处理器指令的操作数：表示参与操作的对象

  具体的常量

  保存在寄存器的数据

  保存在存储器的变量

  dest和src

* 伪指令的参数

  常量、变量名、表达式等

  可以多个，参数之间以逗号分隔

```assembly
msg byte 'Hello,Assembly!',13,10,0;字符串是操作数,后面是参数，定义字符串
mov ax, offset msg;ax获得msg的偏移地址
```

### 注释

分号后的内容



## 源程序框架

数据段、代码段等的定义

程序起始执行的位置

汇编结束的指示

MASM

简化段定义格式

```assembly
;example.asm
	.model small
	.stack
	.data
	...;在数据段定义数据
	.code
	.startup
	...;在代码段填入指令序列
	.exit 0
	...;子程序代码
	end
```

显示字符串的格式

```assembly
	.model small ;定义程序的存储模型
	.stack ;定义堆栈段
	.data ;定义数据段
string db "Hello world!",odh,0ah,'$';在数据段定义要显示的字符串
	.code ;定义代码段
	.startup ;程序起始点，建立DS、SS
	mov dx,offset string ;指定字符串
	mov ah,9
	int 21 ;利用功能调用显示信息
	.exit 0;程序结束点，返回
	end;汇编结束
```



```assembly
	.data	;定义数据段
	...		;数据定义
	.code	;定义代码段
start:		;程序执行起始位置
	...		;主程序
	exit 0	;程序正常执行结束
	...		;子程序
	end start	;汇编结束
```

### INCLUDE包含伪指令

用于声明常用的常量定义，过程说明，共享的子程序库等，相当于C语言头文件

### 段的简化定义

```assembly
;数据段定义伪指令
.data	;创建一个数据段
;代码段定义伪指令
.code	;创建一个代码段
;堆栈段定义伪指令
.stack	;创建一个堆栈段，window自动维护，不用设置
```

### 程序的开始和结束

* 程序开始执行的位置

  使用一个标号（eg：START）

  作为汇编结束`END`伪指令的参数

* 应用程序执行终止

  语句`EXIT 0`终止程序执行

  返回操作系统，并提供一个返回代码0

* 源程序汇编结束

  使用`END`伪指令语句

```assembly
start:		;程序执行起始位置
	...		;主程序
	exit 0	;程序正常执行结束
	...		;子程序
	end start	;汇编结束
```

执行终止不等于汇编结束

end是结束start

程序结束的意思是把控制权交还给操作系统

汇编结束是源程序到此结束

框架可作为模板文件



### DOS系统功能调用

21H中断时DOS提供的用于调用系统功能的中断

#### 功能调用

1. 在AH寄存器中设置系统功能调用号
2. 在指定寄存器中设置入口参数
3. 执行指令INT 21H实现中断服务程序的功能调用
4. 根据出口参数分析功能调用执行情况

#### 字符输出的功能调用

INT 21H 

功能号：AH=02H

入口参数：DL=字符的ASCII码

功能：在显示器当前光标位置显示给定的字符，光变右移一个字符位置

```assembly
mov ah,02h ; 设置功能号：ah<-02h
mov dl,"?" ; 提供入口参数
int 21h ; 打印显示"?"
```

0DH回车，0AH换行，都会相应的处理

<hr/>
#### 字符串输出功能的调用

功能号：AH=09H

入口参数：DS:DX=欲显示字符串在主存中的首地址

可以输出回车换行

```assembly
string db "Hello, Everybody!",0dh,0ah,'$';在数据段定义要显示的字符串
mov ah,09h ;设置功能号：ah <- 09h
mov dx,offset string ;提供入口参数：dx <- 字符串的偏移地址
int 21h ;DOS功能调用
```

<hr/>
#### 字符输入的功能调用

DOS功能调用INT 21H

功能号：AH=01H

出口参数：AL=字符串的ASCII码

功能：获得按键的ASCII代码值

调用此功能时，若无键按下，则会一直等待，直到按键后才读取该键值

```assembly
getkey: mov ah,01h ;功能号：ah <- 01h
				int 21h ;功能调用
				cmp al,'Y' ;处理出口参数al
				je yeskey ;是“Y”
				cmp al,'N'
				je nokey ;是“N”
				jne getkey
				...
yeskey: ...
nokey:  ...
```



#### 字符串输入的功能调用

DOS功能调用INT 21H

功能号：AH=0AH

入口参数：DS:DX=缓冲区首地址

执行该功能调用时，用户按键，最后用回车确定



#### 缓冲区的定义

* 第一字节事先填入最多欲接收的字符个数（包括回车字符）
* 第二字节将存放实际输入的字符个数（不包括回车符）
* 第三字节开始将存放输入的字符串



#### 按键判断的功能调用

功能号：AH=0BH

出口参数：AL=0，当前没有按键；AL=FFH，当前已经按键

功能：仅判断当前是否有按下的键，设置AL后退出

##### 按键判断：按任意键继续

```assembly
getkey:mov ah,0bh
			int 21h
			or al,al ;al=0?
			jz getkey
			; al=0,没有按键，继续等待
			;等同于 mov ah,01h
						; int 21h
```





## 信息显示程序

### 信息显示



```assembly
		.model small ;定义程序的存储模型
		.stack ;定义堆栈段
		.data ;定义数据段
string db "Hello, Everybody!" ,0dh,0ah,'$'
		;在数据段定义要显示的字符串
		.code ;定义代码段
		.startup ;程序起始点，建立DS、SS
		mov dx, offset string ;指定字符串
		mov ah, 9
		int 21h ;利用功能调用显示信息
		.exit 0 ;程序结束点，返回DOS
		end ;汇编结束
```

<hr/>










```assembly
	;在数据段给出这个字符串形式的信息
	.data	
msg byte 'Hello,Assembly!',13,10,0	;13,10表示'\n'	
	;0表示字符串的结尾（高级语言自动有）	定义要显示的字符串
	;在代码段编写要显示字符串的程序
	.code
start:
	mov ax, offset msg	;指定字符串的偏移地址，ax寄存器，显示的入口参数存放的地方
	call dispmsg	;调用子程序显示信息
	exit 0
	end start
```





## 常量表达

常量是一个确定的数值，可直接编码于指令代码中，不是保存在存储器中可变的便令啊

支持的多种常量表达形式

* 常数：直接给出数值
* 字符和字符串：ASCII
* 符号常量
* 数值表达式

符号名 `equ` <字符串>

数值表达式

加减乘除

数值作为地址，数值表达式成为地址表达式

* 地址表达式只能使用加减

* 指示地址移动常量表示的若干个字节存储单元

  地址+常量

  地址-常量

| 算术表达式 | 67h-52h |
| ---------- | ------- |
| 地址表达式 | var+4   |

### 数据表达程序

```assembly
const1 byte 100,100d,01100100b,64h,'d';不同进制和形式表达了同一个数值，机器指令中都是二进制
;.00000000 64 64 64 64 64
mov ax,offset const1	;从const1开始显示
call dispmsg
```



0DH回车，0AH换行

数字0用于字符串的结尾



## 变量定义

变量

* 随程序运行会发生变化的数据
* 保存在可读写的主存空间

变量的实质是主存单元的数据，因而可以改变

* 变量需要先定义才能使用
* 变量具有属性方便应用

变量表达主存数据，即存储器操作数，一般在程序的数据段中



### 变量的定义

变量名	变量定义伪指令	初值表

变量名：用户起的标识符，表示首元素的**逻辑地址**

变量定义伪指令，byte，word，dw，db等表示**变量类型**

变量初值表是用逗号分隔的一个或多个参数，表示**变量初值**，相当于高级语言的数组

**主要的变量定义伪指令**

| BYTE：字节  | 分配一个或多个字节单元，每个数据是8位、字节量  | char  |
| ----------- | ---------------------------------------------- | ----- |
| WORD：字    | 分配一个或多个字单元，每个数据是16位、字量     | short |
| DWORD：双字 | 分配一个或多个双字单元，每个数据是32位、双字量 | long  |

#### 变量定义的初值表

变量定义是申请存储空间

* 同时还可以进行存储单元初始化
* 即用初值表赋予变量初值

初值表可以有一个或多个参数，多个参数用逗号分隔

* 各种形式的常量

* 使用"?"表示初值不确定，即未赋初值

* 使用复制操作符`DUP`表示多个相同数值

  格式：重复次数	DUP(重复参数)



变量定义之后

* 分配了存储空间
* 赋予了初值（也可不）
* 创建了变量名，可以获知变量的地址和类型

### 八位字节变量定义

* 8位无符号整数0~255
* 8位补码表示有符号整数：-128~+127
* 一个字符（ASCII）
* 压缩BCD：0~99
* 非压缩：0~9

**定义字符串要使用字节变量定义BYTE**

```assembly
msg byte 'Hello',13,10,0
const1 byte 100,64h,'d'
const6 byte 4*4,34h+24
bvar byte ?;表示初值不定，一般用0填充
bvar1 byte 5 dup('$');重复五个
```

可以用变量名来访问首元素，然后偏移地址来访问后面的元素



### 十六位字变量定义

* 16位无符号整数：0~65535
* 16位补码表示的有符号整数：-32768~+32767
* 16位段地址
* 16位偏移地址

```assembly
wvar1 word 0,-32768,65535;每一个值都是字类型，两个字节
wvar2 word ?
minint = 10
wvar3 word 5 dup(minint)
```

* 16位变量定义，使用word伪指令，每个数据是一个字量，占用两个存储单元
* 变量定义的参数可以是有符号数，也可是无符号数

### 三十二位双字变量定义

除了一些数字的表达，还有就是32位逻辑地址（含十六位段地址和十六位偏移地址）



#### 多字节数据的存储顺序

字节编址的主存储器

最小的存储单位：二进制位（比特bit）

8个二进制位是一个字节

一个存储单元保存一个字节量数据

一个存储单元对应一个存储器地址

都有一个唯一的物理地址与之对应



多个字节数据顺序逐个存放在主存相邻单元

从低地址到高地址开始存储

8086最低字节的数据放在最低的地址



### 定位伪指令

定位伪指令控制数据的偏移地址

```assembly
ORG 参数
```

ORG伪指令是将当前偏移地址指针指向参数表达的偏移地址

```assembly
ORG 100h ;从100h处安排数据或程序
ORG $+10 ;使偏移地址加10，即跳过10个字节空间
; $ 表示当前偏移地址值
```



地址操作符实例

```assembly
		org $+10
array db 45,45h
		.code
		mov ax,seg array
		mov ds,ax
		mov bx,offset array ; 等价于lea bx,array
		mov cl,array+4 ; 等价于mov cl,array[4]
		mov ax,es:[2000h]
```



### 变量的地址属性

变量的定义可以：

* 分配存储空间
* 赋初值
* 创建变量名

定义后的变量名具有两类属性

* 地址属性：首个变量所在存储单元的逻辑地址
* 类型属性：变量定义的数据单位

#### 变量的地址属性及地址操作符

变量的地址属性指所在存储单元的逻辑地址，含有段基地址和偏移地址

通过地址操作符获得变量的地址属性值

| 符号             | 作用                             |      |
| ---------------- | -------------------------------- | ---- |
| [ ]              | 括起来的表达式作为存储器地址指针 |      |
| $                | 返回当前偏移地址                 |      |
| OFFSET 名字/标号 | 返回变量名所在段的偏移地址       |      |
| SEG 名字/标号    | 返回段基地址（实地址存储模型）   |      |
| :                | 采用指定的段地址寄存器           |      |

 

数据段

```assembly
bvar byte 12h, 34h
		org $ + 10 ;org指定变量存放位置的指令
		;当前地址(00000002H)+10,等于0000000CH
array word 1,2,3,4,5,6,7,8,9,10
;从0000000C开始存储
wvar word 5678h
		arr_size = $-array;计算出从当前到ARRAY变量所占存储空间，array代表一组变量的首地址，数据段中使用变量名代表其偏移地址
		arr_len = arr_size/2;计算变量个数
dvar dword 9abcdef0h
```



代码段

```assembly
mov al, bvar ;al=12h
; bvar 等同于[bvar]，把bvar所指的第一个数据赋值给al
mov ah, bavr+1 ;ah=34h
;代码段中使用变量名，代表其首个数据（变量值），变量名加减常量指向首个数据的前后单元
mov bx, wvar[2] ;变量名[n]=变量名+n，n表示n个存储单元，指向首个数据的前后单元
; 取出wvar首地址后两个单元后的数据赋值给bx
mov ex, arr_len ;变量个数
mov dx, $ ;在代码段中出现依然表示当前的偏移地址，表示当前这条指令所在的偏移地址
mov si, offset dvar ;获得变量所在的偏移地址
mov di, [si] ;通过地址获得变量值，si作为地址的
mov bp, dvar ;直接获得变量
```

#### 变量的类型属性

数据单位，字节数

类型操作符使用变量名的类型属性

| 操作符               | 作用                                             |
| -------------------- | ------------------------------------------------ |
| 类型名 PTR 名字/标号 | 将变量名按照指定的类型使用，具有指定的类型       |
| THIS 类型名          | 操作数具有汇编时的当前逻辑地址，但具有指定的类型 |
| TYPE 名字/标号       | 返回占有字节空间的字量数值                       |
| LENGTHOF 变量名      | 返回整个变量的数据项数                           |
| SIZEOF 变量名        | 返回整个变量占用的字节数                         |



PTR

```assembly
mov al,byte ptr w_var ;w_var是一个字面量
jmp far ptr n_label ;n_label是一个标号
;可以临时改变名字或标号的类型
```



THIS类型名

```assembly
b_var equ THIS byte ; 按字节访问变量b_var,但与W_var的地址相同
w_var dw 10 dup(0) ;按字访问变量w_var
```



数据段

```assembly
bvar byte 12h, 34h
		org $ + 10 ;org指定变量存放位置的指令
		;当前地址(00000002H)+10,等于0000000CH
array word 1,2,3,4,5,6,7,8,9,10
;从0000000C开始存储
wvar word 5678h
		arr_size = $-array;计算出从当前到ARRAY变量所占存储空间，array代表一组变量的首地址，数据段中使用变量名代表其偏移地址
		arr_len = arr_size/2;计算变量个数
dvar dword 9abcdef0h
```

代码段

```assembly
mov eax, dword ptr array ;定义为字类型的array，但是以双字类型访问，这里使用的是eax32位寄存器
mov bx, type bvar ;获得字节变量类型值，返回1，如果是word，2；dword，4
mov si, lengthof array ;获得变量数据个数
mov di, sizeof array ;获得变量所占的存储空间个数
mov bp, arr_size ;
call disprd ;显示寄存器内容
```



## 寻址方式

### 指令及其操作数

指令有两部分：操作码和操作数

操作码：处理器要执行的操作

不可缺少，助记符表示

操作数：指令执行的参与者

各种操作的对象，需要通过地址指示

### 寻址方式详解

通过地址访问数据或指令

数据寻址：

* 指令执行过程中，访问所需要操作的数据（操作数）

指令寻址：

* 一条指令执行后，确定执行的下一条指令的位置

### 数据寻址方式

数据来自主存储器 --> **存储器寻址**

存储器是专门用于存放数据和指令的

通过数据所在的单元地址，找到存储器中的数据



数据已经保存在指令代码中 --> **立即数寻址**

某些指令当中已经包含了它所需的操作数

这样的操作数，把指令代码取出来，就已经把所需的操作数取出来了



从寄存器中获得所需的操作数 --> **寄存器寻址**



sumup

* 立即数寻址——数据在指令代码中，用**常量**表示
* 寄存器寻址——数据在寄存器中，用**寄存器名**表示
* 存储器寻址——数据在主存中，用**存储器地址**代表



### 立即数寻址

操作数从指令代码中得到，立即数imm

```assembly
mov ax, 33221100H ;imm,直接写出

const = 64
bvar byte 87h, 49h
dvar dword 12345678H, 12
.code
mov al, 12h ;十六进制常数
mov ah, 'd' ;字符
labl: mov bx, -1 ;十进制补码
mov cx, const ;符号常量
mov dx, const*4/type dvar ;表达式
mov si, offset bvar ;变量的偏移地址
mov di, labl ;标号的偏移地址；；代码段使用标号名代表其偏移地址
mov bvar, 01001100b ;立即数本身没有类型，看dest的类型
mov dvar+4, 12h ; 12h就是个双字类型
```

立即数寻址：

* 操作数紧跟操作码，是机器代码的一部分
* 操作数从指令代码中得到，即立即数imm

立即数寻址方式只用于源操作数src

* 常用来给寄存器和存储单元赋值
* 用常量形式直接表达



### 寄存器寻址reg

```assembly
mov bx, ax ;dest和src都是寄存器
mov al, 12
mov bvar, cl
mov edi, si ;必须是同样类型的寄存器
```



寄存器寻址：

* 操作数存放在处理器的内部寄存器中
* 用寄存器名表示它的内容

寄存器寻址方式简单快捷，最常使用

* 绝大多是指令采用通用寄存器
* 部分指令支持专用寄存器（如段寄存器）

执行速度很快



### 存储器寻址

操作数在主存中，通过存储器覅之指示

* 指令代码表达形式地址

* 由形式地址结合规则经过计算得到有效地址EA（Effective Address）

  处理器将有效地址转换为物理地址访问存储单元

  操作码	寻址方式	形式地址

  ​                             ||

​                                有效地址

​                                      ||

​                                  操作数

重点，获得有效地址



#### 存储器的逻辑地址

存储器使用逻辑地址

* 段寄存器指示段基地址
  * 绝大部分情况使用默认规定吗，无需表达
  * 有时候需要显式说明（成为段超越）
* 偏移地址由各种存储器寻址方式计算
  * 称为有效地址EA

逻辑地址 = 段基地址 : 偏移地址



#### 段寄存器指示段基地址

绝大多是默认规定

* 读取指令，一定是代码段CS
* 堆栈操作，针对堆栈段SS
* 读写数据，默认在数据段DS

有时候需要显式说明（段超越）

* 使用段超越指令前缀（段寄存器后跟冒号）

```
CS: DS: SS: ES: 
```



段寄存器的默认和超越

|   访问存储器方式    | 默认 |     可超越     |  偏移地址  |
| :-----------------: | :--: | :------------: | :--------: |
|      读取指令       |  CS  |       无       |     IP     |
|      堆栈操作       |  SS  |       无       |     SP     |
|    一般访问数据     |  DS  | CS ES SS FS GS | 有效地址EA |
| BP/SP基址的数据访问 |  SS  | CS ES DS FS GS | 有效地址EA |
|     串指令的src     |  DS  | CS ES SS FS GS |     SI     |
|    串指令的dest     |  ES  |       无       |     DI     |



16位有效地址的组成

基址寄存器+变址寄存器+位移量

​       ||                   ||              ||

 BX或BP         SI或DI     8或16位有符号值

 B：Base        I：Index

BX+SI+80h



#### 直接寻址方式

直接寻址：有效地址只有位移量部分，直接包含在指令代码中

有效地址在指令中直接给出，默认的段地址在DS段寄存器，可用段超越前缀表示

* 用变量名（或加[ ]）表示偏移地址

```assembly
mov ax,[2000h] ; AX<-DS:[2000h]
```



```assembly
count word 4050h
mov cx, count
mov cx, [count]
mov cx, ds:[4050h];count这个数据是在代码段中的
;有效地址4050h，操作完成获得单元存储的数据
```

```assembly
bvar byte 87h,49h
wvar word 1234h,12
mov cl, bvar ;取出偏移量为0的地址的数据
mov dx, dvar
mov bvar+1, dh ;将dh中的内容推送到bvar+1地址所指的单元

mov dvar+4, dvar ;非法操作，不可主存到主存
```



sumup

存储器的直接寻址

* 指令代码中直接给出有效地址

直接寻址常用于存取变量

* 直接使用变量名表达：变量名
* 变量名加减一个常量：变量名+n    变量名-n
* 用中括号：[变量名]     变量名[n]

直接寻址的操作数具有变量定义的类型

* 又是需要要ptr操作符进行类型转换

用于存取变量，比立即数寻址要慢



#### 寄存器间接寻址方式

有效地址存放在基址寄存器BX或变址寄存器SI、DI中

默认的段地址是DS段寄存器，可使用段超越前缀改变

```assembly
mov ax,[si] ; ax<-DS:[SI]
```

操作数来自主存

有效地址放在寄存器中

寄存器内容=偏移地址=有效地址

* 用[寄存器]表达

```assembly
mov dx,[bx] ;字量传送 
;bx中的内容不是操作数，而是操作数的有效地址，把这个地址给处理器，让处理器按照这个有效地址来找到内存单元，把单元中的数据取出，送达给dx
mov cx,[si] 
mov [edi],al ;字节量 
;把al中的数据送到edi所指的存储单元中，edi中的内容是作为有效地址的
```

寄存器间接寻址的数据

由另一个操作数的存储器或变量类型决定

只能表明要从寄存器所指的内存单元中去访问数据，但是并不决定这次访问的数据量

数据量大小由另一个操作数决定

即由没有比括起来的寄存器决定

##### 寄存器间接寻址未说明数据类型

```assembly
mov [bx], 100 ;错误，数据类型不明确
mov byte ptr [bx],100
;立即数没有类型，需要显式说明
```

```assembly
;字符串复制
srcmsg byte 'Try your best',0
dstmsg byte sizeof srcmsg dup(?) ;定义了一样的长度,单元个数
mov cx, lengthof srcmsg ;获取字符的长度
mov si, offset srcmsg ;获取当前偏移地址
mov di, offset dstmsg
mov al, [si] ; 去源串一个字符给al
mov [di], al ; 将al传送给目的串位置
add si, 1
add di, 1
again: mov al, [si]
		;...
		loop again
```

有点类似指针的操作     



存储器的寄存器间接寻址

*  有效地址通过寄存器提供

方便对数组的元素或字符串的字符进行操作

* 数组（字符串）的地址赋值给寄存器
* 增减寄存器值指向不同的元素

寄存器间接寻址的操作数没有类型

* 其类型由另一个操作数的寄存器或变量类型决定
* 若另一个操作数也无类型，需要显式说明



与寄存器寻址的不同，寄存器寻址，寄存器中放的就已经是我们需要的操作数了，而间接是，寄存器中放的仅仅是操作数的有效地址，需要通过它来指向，存储单元，找到操作数



#### 寄存器相对寻址方式

有效地址是寄存器内容与位移量之和，寄存器可以是BX/BP或SI/DI

* 寄存器要用中括号括起来

```assembly
;无类型
mov si, [bx+4] ;位移量：4
mov di, [bp-08h] ;-08h
;count定义的类型
mov ax, count[si] ;等价于[si+count],[count][si] 位移量：count
;表示变量所在的偏移地址用作相对寻址的位移量
```

主存采用字节编址

地址的加减以主存字节单元为单位

```assembly
srcmsg byte 'Try your best',0
dstmsg byte sizeof srcmsg dup(?)
mov cx, lengthof srcmsg ;控制循环次数
mov bx, 0 ;初值为0 
mov al, srcmsg[bx];
mov dstmsg[bx], al;
add bx, 1
again: mov al, srcmsg[bx] ;传送一个字符
		;..
		loop again
```

sumup

存储器的寄存器相对寻址

* 有效地址通过寄存器内容与位移量相加获得

方便对数组元素进行操作，

* 数组的首地址作为位移量
* 寄存器赋值0，或元素个数
* 增减寄存器值指向不同的元素

位移量是数字常量，寄存器相对寻址的操作数没有类型

* 位移量用变量名表示，具有变量的类型



#### 基址变址寻址方式

有效地址由基址寄存器（BX或BP）的内容加上变址寄存器（SI或DI）的内容构成：

有效地址=BX/BP+SI/DI

段地址对应BX基址寄存器默认是DS，对应BP基址寄存器默认是SS；可用段超越前缀

```assembly
mov ax,[bx+si]
mov ax,[bp+di]
mov ax,ds:[bp+di]
```



#### 相对基址变址寻址方式

有效地址是基址寄存器(BX/BP),变址寄存器(SI/DI)与一个8位或16位位移量之和

有效地址=BX/BP+SI/DI+8/16位位移量

段地址对应BX基址寄存器默认是DS,对应BP基址寄存器默认是SS;可用段超越前缀

```assembly
mov ax,[bx+si+06h]
```



![image-20191118181235109](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20191118181235109.png)



## 数据传送类指令

数据传送

* 把数据从一个位置传送到另一个位置

除标志寄存器传送指令外，均不影响状态标志

`MOV` `XCHG` `PUSH` `POP` `LEA`

### MOV

传送是拷贝传送

把一个字节、字或双字的操作数从源位置传送至目的位置

```assembly
mov reg/mem,imm
mov reg/mem/seg,reg
mov reg/seg,mem
mov r16/m16,seg
```

禁止主存到主存的数据传送



#### 立即数传送

`mov reg/mem,imm`

```assembly
;寄存器reg为dest
mov al,200 ;i8
mov ax,200 ;i16
```

```assembly
;存储器mem为目的操作数
mov bvar,byte ptr 200 ;i8
mov [bx],word ptr 200 ;i16,寄存器间接寻址，没有明确操作类型
```

<hr/>
#### 寄存器传送

`mov reg/mem/seg,reg`

```assembly
;寄存器reg为目的操作数
mov al,ah ;r8
mov ax,bx ;r16
;要求操作数类型一致
```

```assembly
;存储器mem为dest
mov bvar, cl ;r8
mov [bx], cx ;r16
;寄存器本身决定了传送的数据类型
```

```assembly
;段寄存器seg为dest
mov ds, bx

```



#### 存储器传送

`mov reg/seg, mem`

```assembly
;寄存器reg为dest
mov dl ,bvar ;m8
mov dx ,[bx] ;m16
```

```assembly
;段寄存器seg为dest
mov ds ,wvar ;m16
mov es ,[bx] ;m16
mov ss ,[bp+8] ;m16
;由于16位的段寄存器决定的
```

#### 段寄存器传送

`mov r16/m16 ,seg`

```assembly
;寄存器r16为目的操作数
mov ax,ds
mov dx,es
mov si,fs
mov di,gs
```

```assembly
;存储器m16为dest
mov wvar,ds
mov [bx],ss
mov [si-8],cs
mov [bp+8],cs
```



#### 非法传送

1. 两个操作数的类型不一致

   源操作数是字节,而目的操作数是字

2. 两个操作数不能都是存储器

   主存之间的直接传送是不允许的

3. 段寄存器的操作有一些限制

   段寄存器属专用寄存器,操作能力有限



### PUSH和POP

堆栈操作指令

堆栈一个特殊的存储区域

* 存取原则：先进后出FILO

基本操作入栈出栈



**处理器的堆栈向下生长**

![image-20191029190910107](img\image-20191029190910107.png)



数据压入堆栈、SP逐渐减小

数据弹出堆栈、SP逐渐增大



#### PUSH

```assembly
PUSH r16/m16/i16/seg
;SP=SP-2
;SS:[SP]=r16/m16/i16/seg
```

* 先将SP减小作为当前栈顶
* 后将src送到当前栈顶

```assembly
;进栈指令
push ax
;等价于
sub sp,2
mov [sp],ax
```



#### POP

```assembly
POP r16/m16/seg
;r16/m16/seg=SS:[SP]
;SP=SP+2
```

* 先将栈顶数据传送到目的操作数
* 后将SP增加作为当前栈顶

```assembly
;出栈指令
POP ax
;等价于
mov ax,[sp]
add sp,2
```



```assembly
.data
ten = 10
wvar word 6776h, 1234h
.code
mov ax,wvar+2
push ax
push word ptr ten
push wvar
pop ax ;栈顶数据弹出到ax
pop wvar+2
mov bx,wvar+2 ;栈顶数据弹到wvar+2
pop cx ;栈顶数据弹出到cx
```



## 地址传送指令

### LEA

装入有效地址

```assembly
lea dx,mem;把偏移地址存入dx
```

地址传送指定LEA（Load Effective Address）

地址传送指令获取存储器操作数的地址

`LEA r16/r32,mem`

r16 <-- mem的有效地址EA（不需要类型一致）

把有效地址传送给寄存器



#### LEA指令类似地址操作符OFFSET的作用

LEA指令在执行时计算出偏移地址

OFFSET操作符在汇编阶段取得变量的偏移地址

OFFSET无需再执行时计算、指令执行速度更快

LEA指令能获取汇编阶段无法确定的偏移地址

```assembly
lea di,var
mov di,offset var
;功能相似
```



#### 地址传送程序

```assembly
wvar word 4142h;
mov ax , wvar ; ax获得了wvar的值
lea si , wvar ; si获得了wvar的地址
mov bx , [si] ;寄存器间接寻址，根据si指向的地址，bx获得了wvar的值
mov di , offset dvar ;di获得了wvar的地址
mov cx , [di] 
```

<hr/>
```assembly
lea dx , [si+di*4+100h]
;lea指令在计算地址时，可进行加和位移操作，而offset不可
```



sumup

* `LEA`指令获得存储器操作数的有效地址
  * 在`LEA`指令执行时计算地址
  * 对任何存储器寻址方式都可用
* 对存储器的直接寻址
  * 建议使用`OFFSET`操作符在汇编阶段获得地址
* 对存储器的其他寻址
  * 只能使用`LEA`指令获得地址





## 算术类指令

### 进位和溢出标志

状态标志是处理器最基本的标志

1. 作为加减运算和逻辑运算的辅助结果
2. 构成各种条件，实现程序分支

| 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| OF   | DF   | IF   | TF   | SF   | ZF   | 0    | AF   | 0    | PF   | 1    | CF   |



#### 进位标志CF(Carry Flag)

* 当加减运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF=1；否则CF=0

* 针对无符号整数，判断加减结果是否超出表达范围



#### 溢出标志OF(Overflow Flag)

* 有符号数加减结果有溢出，则OF=1；否则OF=0
* 针对有符号整数，判断加减结果是否超出表达范围

溢出会导致错误结果

判断：

* 只用当两个相同符号数相加(含有两个不同符号数相减)
* 运算结果的符号与原数据相反时，产生溢出



#### 进位和溢出的区别

进位标志反映无符号整数运算结果是否超出范围

* 有进位，加上进位或借位后运算结果仍然正确

溢出标志反映有符号整数运算结果是否超出范围

* 有溢出，运算结果已经不正确

处理器按照无符号整数求得结果

* 设置进位标志CF
* 设置溢出标志OF



有符号数，注意溢出

无符号数，注意进位



### 零标志，符号标志和奇偶标志

#### 零标志ZF(Zero Flag)

运算结果为0，则ZF=1，否则ZF=0

八位运算输出八位结果



#### 符号标志SF(Sign Flag)

运算结果最高位为1，则SF=1；否则SF=0

看的是八位的运算结果而不是进位



### 奇偶标志PF(Parity Flag)

当运算结果最低字节中"1"的个数为**0或偶数**时，PF=1；否则PF=0

(仅最低8位"1"的个数)



eg:

| 8位加法运算及结果             | CF   | OF   | ZF   | SF   | PF   |
| ----------------------------- | ---- | ---- | ---- | ---- | ---- |
| 00111010+01111100=[0]10110110 | 0    | 1    | 0    | 1    | 0    |
| 10101010+01111100=[1]00100110 | 1    | 0    | 0    | 0    | 0    |
| 10000100+01111100=[1]00000000 | 1    | 0    | 1    | 0    | 1    |



### 影响状态标志的指令

需要关注对标志影响的主要指令：

* 加减运算指令
* 逻辑运算指令
* 移位运算指令·

只用于影响标志的特殊指令1：比较指令`CMP`

* 进行减法运算
* 用于判断两个数据大小、是否相等

只用于影响标志的特殊指令2：测试指令`TEST`

* 进行逻辑与运算
* 用于判断某位为0或为1等

利用状态标志来判断转移分支和循环



### `ADD`指令

加法指令

加减指令除了和差结果，进借位、溢出等状态标志、也是结果的一部分

* 加法指令`ADD`
* 带进位加法指令`ADC`
* 增量指令`INC`
  * 除了`INC`不影响进位标志`CF`外
  * 其他指令按照定义影响全部状态标志位
  * 按照运算结果相应设置各个状态标志位0/1



`ADD`

目的操作数加上源操作数，并送到目的操作数

```assembly
ADD reg, imm/reg/mem ;reg <- reg+imm/reg/mem
ADD mem, imm/reg ;mem <- mem+imm/reg
```

* 按照定义影响状态标志位
* 支持字节、字、双字数据的运算

```assembly
mov ax, 0aafh ;
add al, 27h ;8位加法，最高位是D7
```

`PF`标志只利用低8位结果



#### 大小写字母的转换

```assembly
;确认是大写字母。+20h为小写字母
add al, 20h; 20h = 'a' - 'A'
```



### `SUB`减法指令

* 减法指令`SUB`
* 带借位减法指令`SBB`
* 减量指令`DEC`
* 求补指令`NEG`
* 比较指令`CMP`

**除了`DEC`不影响CF标志外，其他按定义影响全部状态标志位**



#### 减法指令`SUB`

目的操作数减去源操作数，所得差送到目的操作数

```assembly
SUB reg, imm/reg/mem 
SUB mem, imm/reg
```

按照定义影响状态标志位

支持一些数据运算

```assembly
mov ax, aaffh;
sub al, 27h;
```

用`al`中的内容减去`27h`，再存在`al`中



### `INC` `DEC` `NEG`指令

#### 增量指令`INC`(increment)

* 只有一个操作数：寄存器或存储单元
* 对操作数+1，再将结果返回原处
* 用于计数器和地址指针的调整
  * 不影响进位CF标志，影响其他状态标志位

操作类似于`i++`

```assembly
inc cx ;内容+1放回原寄存器
inc word ptr[si] ;所指内容+1
inc wvar ;mem
inc wvar[di] ;wvar+id所指单元内容+1放回原位
```



#### 减量指令`DEC`(decrement)

* 只有一个操作数：寄存器或存储单元
* 对操作数-1，再将结果返回原处
* 用于计数器和地址指针的调整
  * 不影响进位CF标志，影响其他状态标志位

操作类似于`i--`

```assembly
dec cx ;内容-1放回原寄存器
dec word ptr[si] ;所指内容-1
dec wvar ;mem
dec wvar[di] ;wvar-di所指单元内容-1放回原位
```



配合操作可用作字符串的扫描

```assembly
msg byte "welcome",0 ;数据段
mov cx, (lengthof msg)-1 ;保存字符个数，减去末尾的0
dec cx;
inc cx
```



#### 求补指令`NEG`(negative)

* 对操作数执行求补运算，即用0-操作数
* 对标志的影响和用零作减法的SUB指令一样
* 可用于对负数求补码或由补码求其绝对值

操作类似`0-i`

```assembly
neg al
neg byte ptr [bx]
neg wvar [si]
```



sumup

* `INC`、`DEC`、`NEG`是加减运算的辅助指令
  * `INC`实现指针+1、不影响CF
  * `DEC`实现指针-1、不影响CF
  * `NEG`进行数据求补
* 这些指令给出一个操作数的位置，既是源操作数也是目的操作数



### 逻辑运算指令

针对二进制位进行操作、实现位控制的指令

* 逻辑运算指令
* 移位指令
* 循环移位指令
* ······

进行一位或若干位处理，采用位操作类指令

| AND  | OR   | NOT  | XOR  | TEST |
| ---- | ---- | ---- | ---- | ---- |
| 与   | 或   | 非   | 异或 | 测试 |

除了`NOT`指令不影响标志位，其他指令

* 使`OF=CF=0`
* 根据结果按定义影响`ZF`、`SF`和`PF`

都是按照二进制的位来进行与或非

####  逻辑运算的屏蔽作用

* AND复位0某些位（与0），不影响其他
* OR置位1某些位（或1），不影响其他
* XOR囚犯某些位（异或1），不影响其他

同样也可用于大小写转换

大写字母的ASCII值第五位为0，小写字母为1

大写　=　小写　AND　DFH

小写　＝　大写　OR　20h

逻辑运算还可以用于清零



### 移位指令

* 逻辑左移指令`SHL`
* 逻辑右移指令`SHR `
* 算术左移指令`SAL`
* 算术右移指令`SAR`

```assembly
SHL reg/mem, 1/cl ;移位数据和移位位数
SAL reg/mem, 1/cl
;每位同时左移，最低为补0，最高位进入CF
```

完成的操作是一样的

```assembly
AL = 11110101B
SHL AL ,1
;执行后AL=11101010B，CF=1
```

<hr/>
逻辑右移

```assembly
SHR reg/mem, 1/cl
;每位同时右移，最高位补0，最低位进入CF
```

算术右移

```assembly
SAR reg/mem, 1/cl
;每位同时右移，最高位不变，最低位进入CF
```



移位是以位为单位将数据向左或向右的移动

* 左移指令`SHL`、`SAL`，两者相同
* 右移指令`SHR`、`SAR`，两者不同

算术右移针对有符号数（补码）移位、以便保持最高位不变、即数据符号不变



### 循环移位指令

* 不带进位循环左移指令`ROL`	

* 不带进位循环右移指令`ROR`

* 带进位循环左移指令`RCL`

* 带进位循环右移指令`RCR`

  R:Rotate	L:Left	R:Right	C:Carry flag

```assembly
ROL reg/mem, 1/cl
;同时左移，最高位循环进入最低位和CF
;执行前AL=11100101B
ROL AL, 1
;执行后AL=11001011B，CF=1，不带进位的循环左移

ROR reg/mem, 1/cl
;同时右移，最低为进入最高位和CF

RCL reg/mem, 1/cl
;CF作为附加位，各位同时左移，CF进入最低位，CF原来的值形成环，所以要知道CF的值

RCR reg/mem, 1/CL
;CF作为附加位，各位同时右移，最低位进入CF，CF原来的值形成环，所以要知道CF的值
```



### 中断指令INT



## 顺序程序结构

### 移位实现乘法程序

* 左移一位相当于数值乘以2
* 右移一位相当于数值除以2（余数在CF中）
  * 逻辑右移一位是无符号数除以2
  * 算数右移一位是有符号数除以2

可以提高操作的速度

```assembly
;data
wvar word 34000
;code
xor eax,eax ;eax=0
mov ax,wvar ;ax=要乘以10的无符号数
shl eax,1 ;左移一位
mov ebx,eax ;ebx=eax*2
shl eax,2 ;左移；两位
add eax,ebx ;得到了一个乘以10
```

`mul eax,10`



## 分支程序结构

### 指令寻址方式

通过地址访问数据或指令

* 数据寻址：指令执行过程中，访问所需要操作的数据（操作数）
* 指令寻址：一条指令执行后，确定执行的下一条指令的位置

+ 顺序寻址：IP自动增量指向下一条指令，顺序执行接着的下一条指令
+ 跳转寻址：控制流程跳转（转移）到指定指令位置，实现程序分支、循环、调用等结构



#### 顺序寻址：IP自动增量指向下一条指令

顺序指向接着的下一条指令，CPU自己会



#### 跳转寻址

##### 指令的相对寻址

提供目标地址相对于当前指令指针IP的位移量

目标地址（转移后的IP）=当前IP+位移量

相对寻址都是段内转移

目标地址=目的地址=转移地址



##### 指令的直接寻址

目标地址=指令操作数

理论上是可以段内或段间转移



##### 指令的间接寻址

指示寄存器或存储单元

目标地址来自寄存器或存储单元、间接获得

* 寄存器间接寻址：用寄存器来保存目标地址，找到寄存器的内容作为目标地址
* 存储器间接寻址：用存储单元保存目标地址



#### 程序流程的控制转移

程序代码在代码段

* CS：指明代码段在主存中的段基地址
* IP：给出将要执行指令的偏移地址

指令顺序寻址，程序顺序执行，处理器自动增量

指令跳转寻址，程序控制转移，IP（CS）随之改变



控制转移类指令

`JMP` jump指令

`Jcc` 条件转移指令

`LOOP`循环指令



##### 段内转移

在当前代码段范围内的程序转移

* 不需要更改CS，只需要改变IP（偏移地址）

程序只有一个代码段，或者只在段内跳转



被称为“近转移”，类型属性使用"NEAR"关键字

转移范围在127~-128字节之间，又称为“短转移” SHORT



##### 段间转移

从当前代码段跳转到另一个代码段

* 需要更改CS和IP

被称为远转移 "FAR"



#### JMP指令

##### 无条件转移指令（JMP）

```assembly
JMP label ;程序转向label标号指定的地址
;段内相对寻址，段间直接寻址
JMP reg32/reg16 ;程序转向寄存器指定的地址
;寄存器间接寻址
JMP mem32/mem16 ;程序转向存储单元指定的地址
;存储器间接寻址
```



```assembly
;data
nvar dword ?

;code
	jmp labl1 ;跳转到labl1指令，跨过了一条指令，位移量1个字节、相对寻址短转移
	nop

labl1: jmp near ptr labl2 ;跳转到labl2，位移量4个字节、相对寻址、近转移
			 nop ;一个空操作指令
			 
labl2: mov eax,offset labl3 ;获得了labl3的地址
			 jmp eax ;跳转到eax内容所指定的位置，跳转到labl3，这是一个寄存器的间接寻址
			 nop
		
labl3: mov eax,offset labl4
			 mov nvar,eax ;数据的存储器直接寻址
			 jmp nvar ;存储器间接寻址
			 nop
			 
			 ;也可写作
			 mov ebx,offset nvar
			 jmp near ptr[ebx] ;数据的寄存器间接寻址
			
labl4:...
```



实现无条件的程序流程转移

对应着C语言的goto语句

处理器中必不可少的指令



#### Jcc指令

##### 条件转移指令（Jcc）

jump with condition

根据指定的条件确定程序是否发生转移

`Jcc label`

；条件满足，发生转移

；否则，顺序执行下一条指令

label表示目标地址

采用段内相对寻址



##### 判断的标志条件cc

共16条指令，分为两类

* 单个标准状态作为条件

  五个标志状态`ZF` `CF` `SF` `OF` `PF`的十种状态

* 两数大小关系作为条件

  比较无符号整数大小

  4种情况：低于、不低于、低于等于、高于

  比较有符号整数大小

  4种情况：小于、不小于、小于等于、大于



###### 利用零为标志ZF的条件转移指令

```assembly
;判断条件：运算结果为0、两数相等（标志ZF=1）
JZ label ;jump if zero
JE label ;jump if equal
;判断条件：结果不为0、不相等（标志ZF=0）
JNZ label ;jump if not zero
JNE label ;jump if not equal
```



###### 利用进位标志CF的条件转移指令

```assembly
;判断条件：运算结果有进位（借位）（标志CF=1）
JC label ;jump if carry
;判断条件：如果没有进位（借位）（标志CF=0）
JNC label ;jump if not carry
```



###### 利用溢出标志OF的条件转移指令

```assembly
;判断条件：运算结果有溢出（标志OF=1）
JO label ;jump if overflow
;判断条件：结果没有溢出（标志OF=0）
JNO label ;jump if not overflow
```

* 溢出标志OF针对有符号整数加减运算
* 进位标志CF针对无符号整数加减运算



###### 利用符号标志SF的条件转移指令

```assembly
;判断条件：运算结果是负、最高位为1（标志SF=1）
JS label ;jump if sign
;判断条件：结果为正、最高位为0（标志SF=0）
JNS label ;jump if not sign
```

* 有符号整数采用补码，最高位是符号位
* 符号位为1，表示负数；符号位为0，表示正数



###### 利用奇偶标志PF的条件转移指令

```assembly
;判断条件：低8位结果中1的个数位偶或0（标志PF=1）
JP label ;jump if parity
JPE label ;jump if parity even
;判断条件：低8位结果中1的个数为奇（标志PF=0）
JNP label ;jump if not parity
JPO label ;jump if parity odd
```



###### 两个无符号整数大小关系的条件转移指令

```assembly
;判断条件：低于、不高于等于（标志CF=1）
JB ;jump if below
JNAE ;jump if not above or equal
;判断条件：不低于、高于等于（标志CF=0）
JNB ;jump if not below
JAE ;jump if above or equal
```



###### 两个有符号整数大小关系的条件转移指令

```assembly
;判断条件：大于、不大于等于（标志SF不等于OF）
JL ;jump if less
JNGE ;jump if not greater or equal
;判断条件：不小于、大于等于（标志SF=OF）
JNL ;jump if not less
JGE ;jump if greater or equal
```



##### 产生条件的指令

常用指令1：比较指令CMP

* 进行减法运算
* 用于判断两个数据大小、是否相等

常用指令2：测试指令TEST

* 进行逻辑与运算
* 用于判断某位为0或为1等

其他指令：能够影响状态标志的指令

* 加减运算指令
* 逻辑运算指令
* 移位指令



###### 比较指令CMP（compare）

CMP与SUB

将目的操作数减去源操作数

* 差值不送回目的操作数
* 按照减法结果影响状态标志

```assembly
CMP reg,imm/reg/mem ;reg-imm/reg/mem
CMP mem,imm/reg ;mem-imm/reg
```

根据标志状态获取两个操作数的大小关系

给条件转移等指令使用其形成的状态标志



###### 测试指令TEST

AND与TEST

按位进行逻辑与运算，不返回逻辑与结果

```assembly
TEST reg,imm/reg/mem ;reg 与 imm/reg/mem
TEST mem,imm/reg ;mem 与 imm/reg
```

TEST指令像AND指令一样设置状态标志

常用于检测一些条件是否满足，一般后接条件转移指令

目的是利用测试条件转向不同的分支



**利用Jcc指令实现分支、循环程序结构**



#### 个数折半程序

对一个无符号整数折半

+ 对数据除以2
+ 数据右移移位实现除以2

如果是偶数、完成

如果是奇数、+1

显示结果



偶数判断

（SHR指令）右移1位对整数折半

如果是偶数、最低位是0

移入CF标志的位为0，完成

如果是奇数、需要加1

```assembly
	mov ax,885
	shr ax,1 ;右移1位
	jnc goeven ;CF=0条件成立，转移
  add ax,1 ;条件不成立 +1
goeven: call dispuid ;显示结果
```



```assembly
	mov ax,885
	shr ax,1 ;右移1位
	jc goodd ;CF=1条件成立，转移
  jmp goeven ;CF=0,转移到显示...这一句很重要，没有jmp就会顺序执行还是会+1
goodd: add ax,1 ;+1
goeven: call dispuid ;显示结果
```



### 单分支结构

#### 分支程序结构

由条件产生和条件判断两部分组成

* 首先，利用比较CMP、测试TEST，或者加减运算、逻辑运算等影响状态标志的指令形成条件

* 然后，利用条件转移指令判断由标志表达的条件并根据标志状态控制程序转移到不同的程序段



只有一个分支的程序，类似于if-then语句

当条件满足，发生转移，跳过分支体

当条件不满足，顺序向下执行分支体



如求绝对值

```assembly
    call readsid;读入数据的子程序
    cmp ax, 0
    jge nonneg ; 满足条件 >0 跳转显示
    neg ax ；求补
nonneg: call dispuid ;
```

与高级语言不同，满足则跳转



### 双分支结构

 双分支程序结构有两个分支

* 条件为真，转移：执行分支体2
* 条件为假，顺序：执行分支体1

**分支体1最后一定要有JMP指令跳过分支体2**，没有指令就会顺序执行就不太对



显示数据最高位程序

```assembly
mov bx,wvar ;数据来自变量
shl bx,1 ;bx最高位移入CF标志
jc one ;cf=1，最高位为1，转移
mov al, '0' ;cf=0，最高位为0
jmp two ;一定要跳过另一个分支
one: mov al,"1" ;al=1
two: call dispc ;显示
```



## 循环指令

### `LOOP`指令

`LOOP label`

功能1：cx <-cx-1	相当于`DEC CX`

功能2：若cx$\neq$0，转移到LABEL	相当于`JNZ label`

否则顺序执行

> 寄存器cx是默认的计数器，目标地址采用相对短转移  



loop指令就相当于

```assembly
dec cx
jnz label
```



### LOOP指令的应用

循环指令，用于实现减量计数的循环控制

```assembly
			mov cx, num ;设置循环的计数初值num
label: ... ;循环体
			loop label ;cx--,未到0继续循环，到0循环结束，顺序执行
```

```flow
op1=>operation: 设置cx
cond1=>condition: loop
op2=>operation: 循环体
e=>end: 结束框
op1->op2->cond1
cond1(yes)->op2
cond1(no)->e
```



> LOOP指令是先减1后判断

```assembly
		mov cx,0 ;设置循环的计数初值
label: loop label ;ex-1,未到0继续循环
```

这里要知道的是，这是个先减1，后继续循环

这里的循环次数是 $2^{32}$次



### JECXZ指令

未避免计数初值为0可能导致的程序错误

设计理JECXZ指令

```assembly
JECXZ label
;cx=0,转移到label，否则顺序执行
```



```flow
st=>start: 开始框
op1=>operation: 设置cx
cond1=>condition: 判断框(是或否?)
cond2=>condition: loop
op2=>operation: 循环体
e=>end: 结束框
st->op1->cond1(no)->op2->cond2(no)->e
cond2(yes)(botton)->cond1
cond1(yes)->e
```

### 数组求和程序

```assembly
        .data
        array word 136,-138,133,120,-161 ;数组
        sum word ?
        ;元素逐个相加，作为循环体
        ;数组个数已知，可用LOOP指令控制计数
        mov cx, lengthof array ;cx=array元素个数
        xor ax, ax ;求和初值为0
        mov bx, offset array;指向首个元素
again:  add ax,[bx];求和
        add bx, 2;指向下一个数组元素
        loop again
        mov sum, ax;保存结果
```



#### 逐个寻址数组元素

* 寻址存储器内的操作实，使用存储器寻址
* 存储器的直接寻址使用于访问单个变量
  * 但不方便改变地址，所以不适合访问数组元素
* 存储器的寄存器间接、相对、变址都使用寄存器
  * 通过修改寄存器内容改变地址，可方便访问数组元素



寄存器的变址寻址

```assembly
        mov bx,0;指向首个元素
again:  add ax, array[bx*(type array)];求和，带比例的变址
        add bx,1 ;指向下一个数组元素
```



### 循环程序结构

1. 循环初始——为开始循环准备必要条件

   设置循环次数、循环体需要的初始值等

2. 循环体——重复执行的程序代码

   其中包括对循环条件的修改等

3. 循环控制——判断循条件是否成立

   决定是否继续循环



> 计数控制循环
>
> 通过次数控制循环
>
> * 计数可以减量进行
> * 也可增量
> * 类似于for
>
> 利用loop减量进行循环，对应do



> 条件控制循环
>
> 根据条件决定是否进行循环
>
> * 使用比较测试等指令设置状态标志、产生条件
> * 使用条件转移指令实现循环空
> * 常需要使用无条件转移指令配合实现循环
>
> 先判断后循环
>
> * 类似while

### 计数控制循环

通过次数来控制循环

常见的是先循环后判断的循环结构



求最大值

```assembly
.data
array word -3,0,20,900,-56
count = lengthof array ;数据元素个数
max word ? ;存放最大值
;从第一个元素开始逐个比较，保留最大值
.code
mov cx,count-1 ;元素个数-1就是循环次数
mov si,offset array
mov ax,[si] ;第一个元素暂时存为最大值

again: add si, 2
			 cmp ax, [si] ;比较
			 jpe next ;已经是则继续
			 ;循环体包含了一个分支程序
			 mov ax, [si] ;不是，顺序执行，取得更大的数据
next: loop again ;计数循环
			mov max, ax;保存最大值
```

```assembly
        ;改成一个相对寻址
        mov cx,count-1 ;循环次数
        xor si,si
        mov ax,array[si];
again: add si,2
        cmp ax,array[si];
        jge next
        mov ax,array[si];
next: loop again
        mov max,ax
```





### 条件控制循环

根据条件决定是否进行循环

* 使用比较、测试等指令设置状态标志、产生条件
* 使用条件转移指令实现循环控制
* 常需要使用无条件转移指令配合实现循环

常见的是“先判断，后循环”结构

#### 统计以0结尾的字符串的个数

```assembly
.data
string byte "Do you have fun?",0 ;以0结尾的字符串
.code
xor bx,bx ;记录字符个数，也用作指向字符的指针
;字符不为0，个数+1，字符是0，字符串结束
again: mov al, string[bx];
      cmp al,0
      jz done ;满足则跳转
      inc bx ;个数+1
      jmp again ;继续循环
done: mov ax,bx ;显示个数
      call dispuid
```



#### 先行判断的条件控制循环类似双分支结构

顺序执行的分支 $\Rightarrow$ 需要重复执行多次的循环体

另一个分支 $\Rightarrow$ 用于跳出循环



```assembly
again: cmp string[bx],0
        jz done
        inc bx
        jmp again
done:
```



双分支结构与“先判断后循环”结构

双分支：条件判断，yes跳转到分支体2，no顺序执行到分支体1

循环：满足条件跳转，不满足条件顺序执行循环体，在循环体中跳转到条件的判断





#### 先行循环的条件控制循环类似单分支结构

分支体 $\Rightarrow$ 就是循环体

顺序执行 $\Rightarrow$ 就跳出循环

```assembly
again: inc bx
			 cmp string[bx],0
			 jnz again
			 ...;退出循环
```

这是一个先循环后判断，满足条件则继续循环，不满足则退出



## 子程序的调用

### 子程序指令

* 主程序（调用程序）

  执行调用指令`CALL`

  调用子程序

* 子程序（被调用程序）

  执行返回指令`RET`

  返回主程序

  返回到CALL指令的下一条指令处

#### 子程序调用指令CALL

CALL指令用在主程序中，实现子程序的调用

1. 将下一条指令的地址压入堆栈（顶部）
2. 转移到目标地址

```assembly
CALL label ;调用标号指定的子程序
CALL reg16 ;调用寄存器指定地址的子程序
CALL mem48/mem32/mem16 ;调用存储单元指定地址的子程序
```

> CALL分成段内调用（近调用）和段间调用（远调用）
>
> 目标地址支持相对寻址、直接寻址或间接寻址



#### 段内CALL和RET指令

```assembly
CALL label
next:...
;相当于
push next ;入栈返回地址sp=sp-4，ss:[sp]=ip
jmp label ;转移目标地址：ip=ip+偏移量

RET ;栈顶数据出栈到指令指针寄存器ip
;ip=ss:[sp],sp=sp+4
;数据进入ip，就作为下一条要执行指令的地址
```



### 子程序调用

主程序遇到CALL name 跳转到名字为name的子程序，在子程序执行到最后遇到RET转回到主程序，进行下一条指令 

```assembly
;代码段，主程序
mov ax,1
mov bp,5  
call subp
retp1: mov cx,3
retp2: mov dx,3
call disprd

;子程序
subp proc ;过程定义，过程名为subp
      push bp
      mov bp,sp
      mov si,[bp+4] ;si=CALL下条指令的偏移地址
      mov di,offset retp2
      mov bx,2
      pop bp
      ret
subp endp ；过程结束
```



### 子程序设计

同主程序

* RET指令返回主程序，CALL指令调用子程序
* 利用过程定义，获得子程序名和调用属性
* 压入和弹出操作要成对使用，保持堆栈平衡
* 子程序开始保护寄存器，返回前相应恢复
* 安排在代码段的主程序之外
* 子程序允许嵌套和递归

#### 过程定义伪指令

```assembly
过程名 PROC
			....;过程体
过程名 ENDP
;过程名为符合语法的标识符
```

MASM会根据存储模型等信息确定子程序的远近调用，并相应产生调用、返回指令



#### 子程序框架

```assembly
标识符 proc ;过程定义（子程序开始）
			push ...1 ;保护寄存器
			push ...2
			...				;子程序体
			pop ...2 ;恢复寄存器
			pop ...1
			ret	;子程序返回
标识符 endp ;过程（子程序结束）
```

子程序和主程序共用一套处理器，可能会冲掉主程序的内容，为了保证主程序的状态，寄存器的内容不改变，子程序需要做一些处理，保护寄存器，把它放入堆栈，有push指令，pop成对出现用于保护，恢复寄存器的时候，是一个相反的顺序，堆栈先进后出



回车换行功能

```assembly
mov al,0dh ;输出回车字符
call dispc
mov al,0ah ;输出换行字符
call dispc
;子程序中调用子程序，实现子程序嵌套
```



来写成一个子程序

```assembly
dpcrlf proc ;回城换行子程序
      push ax;保护寄存器
      mov al,0dh;
      call dispc
      mov al,0ah ;输出换行字符
      call dispc
      pop ax;恢复寄存器
      ret;子程序返回
dpcrlf endp;子程序结束
```



### 参数传递

主程序与子程序之间通过参数传递建立联系

* 入口参数(输入参数)：主程序——>子程序
* 出口参数(输出参数)：子程序——>主程序

参数的具体内容

* 数据本身(传递数值)
* 数据的存储地址(传递地址，传递引用)

参数传递的方法

* 通用寄存器
* 共享变量
* 堆栈



#### 寄存器传递参数

最简单和常用的参数传递方法

把参数存于约定的寄存器

* 少量数据直接传递数值
* 大量数据只能传递地址

带有出口参数的寄存器不能保护和恢复（因为子程序处理完会有结果返回的，如果保护恢复就无法再传递参数了）

带有入口参数的寄存器可以保护，也可以不保护，但最好能保持一致



十六进制显示

```assembly
      ;code main
      mov eax, 1234abcdh ;假设一个数据
      xor ebx, ebx;相对寻址访问字符串
      mov ecx, 8;8位十六进制数
again: rol eax, 4;高4位循环移位进入低4位，AL低四位传递入口参数
      push eax;也可 mov edx, eax， AL传递出口参数，主程序进行保护
      call htoasc ;调用子程序htoasc
      mov regd+4[ebx], al;保存转换后的ASCII码
      pop eax;保护，也可 mov eax,edx;
      inc ebx;
      loop again;
      mov eax, offset regd;
      call dispmsg;显示
      
      ;子程序
htoasc proc ;开始
			and al,0fh ;只取AL的低4位
			or al,30h ;AL高4位变成3
			cmp al, 39h ;是0~9，还是A~F
			jbe htoend
			add al,7 ;是A~F，ASCII码+7
htoend: ret ;子程序返回
htoasc endp ;结束
```

 

### 共享变量传递参数

类似于高级语言中的全局变量

子程序和主程序使用同一个变量名存取数据

如果变量定义和使用不在同一个程序模块中，需要利用PUBLIC、EXTERN声明

共享变量传递参数，子程序的通用性较差

特别适合再多个程序断间、尤其在不同的程序模块间传递数据



二进制输入主程序

```assembly
        ;data
        count = 5
        array dword count dup(0)
        temp dword ? ;共享变量
        ;code main
        mov ecx,count ;输入count个数据
        mov ebx,offset array;ebx间接寻址访问数组
again: call rdbd ;调用子程序，输入一个数据
        mov eax,temp ;获得出口参数（共享变量）
        mov [ebx],eax;存放到数据缓存区
        add ebx,4 
        loop again

        ;使用共享变量直接传递返回值
        ;子程序
        rdbd proc ;出口参数：共享变量TEMP
        push eax ;寄存器保护
        push ebx
        push ecx
rdbd1: xor ebx,ebx ;ebx用于存放二进制结果
        mov ecx,32;限制输入字符的个数

rdbd2: call readc ;输入一个字符
        cmp al,"0";检测键入字符是否合法
        jb rderr ;不合法则转到出错处理
        cmp al,"1"
        ja rderr
        sub al,"0";对输入的字符进行转化
        shl ebx,1;ebx的值乘以2（左移一位）
        or bl,al;BL和AL相加（或）
        loop rdbd2;循环输入字符
        mov temp,ebx;把二进制结果存放TEMP返回
        call dispcrlf;分行
        pop ecx
        pop ebx
        pop eax
        ret
        
rderr: mov eax,offset errmsg ;显示错误信息
        call dispmsg
        jmp rdbd1 ;重新输入
        errmsg byte 0dh,0ah,"Input error,enter agagin:",0
        rdbd endp
```



通过共享变量temp传递参数

整个处理过程，不需要考虑参数传递的问题，处理完了，将要返回的值放在约定的共享变量中就可以了



### 堆栈传递参数

主程序将入口参数压入堆栈

* 子程序从堆栈中取出参数

采用堆栈传递参数常常是程式化的

* 子程序设置ebp等于当前esp
* 利用esp相对寻址访问堆栈中的参数

出口参数通常不使用堆栈传递



高级语言函数调用的参数是指是堆栈传递参数



#### 有符号的平均值

要求：将数组元素求和，除以元素个数，求得平均值；

* 主程序：提供数组地址和元素个数，显示结果
* 子程序：求平均值，返回结果

堆栈传递入口参数

* 压入堆栈元素个数（传数值）
* 压入堆栈数组地址（传地址）

寄存器传递出口参数

* EAX=平均值（传数值）



```assembly
;data
array dword 675,354,-34,198,267,0,9,2371,-67,4257
;code main
push lengthof array;压入数据个数
push offset array;压入数组地址
call mean;调用求平均值子程序
add esp,8;主程序平衡堆栈，弹出8个字节
call dispsid;显示平均值EAX（出口参数）
;代码段，子程序
mean proc; 入口参数：顺序压入个数和地址
push ebp;出口参数：EAX=平均值
mov ebp,esp;
push ebx;保护寄存器
push ecx
push edx
;堆栈传递参数可以程式化，子程序设置bp等于当前sp，利用bp相对寻址访问堆栈中的参数
mov ebx,[ebp+8];ebx=取出的数组地址
mov ecx,[ebp+12];ecx=取出的数据个数
xor eax, eax ;eax保存和值
xor edx，edx ;edx=指向数组元素
mean1: add eax,[ebx+edx*4];求和
add adx,1;指向下一个数据
cmp edx,ecx;比较个数
jb mean1;增量计数循环
cdq ;将累加和eax符号扩展到edx，将eax最高位填入edx所有位
;等同于 mov edx,eax  sar edx,31
idiv ecx;有符号数除法，eax=平均值
pop edx ;恢复寄存器
pop ecx
pop ebx
pop ebp
ret
mean endp
```



### 源文件包含和模块连接

#### 多模块程序结构

程序分段、子程序等实现了程序模块化

开发大型应用程序时常使用

* 多个源程序文件
* 目标代码模块等

组成完整的程序，形成多模块程序结构

> MASM支持的多模块方法
>
> 1. 源文件包含
> 2. 模块连接
> 3. 子程序库
> 4. 库文件包含



#### 源文件包含

大型源程序可以合理的分放在若干个文本文件中

* 各种常量定义、声明语句等组织在包含文件(*.INC)
* 常用的或有价值的宏定义存放在宏定义文件(*.MAC)
* 常用的子程序形成汇编语言源文件(*.ASM)
* 任何文本文件



使用源文件包含伪指令INCLUDE

`include 文件名`

将指定文件内容插入主题源程序文件



##### 源文件包含的使用

被包含文件

* 文件名要符合操作系统规范
* 只能是文本文件
* 内容被插入源文件包含include语句所在的位置

实质仍然是一个源程序

* 只是分开在若干个文件中
* 只需针对主题源程序文件进行汇编、连接



##### 模块连接

子程序单独编写成一个源程序文件

* 使用共用伪指令PUBLIC和外部伪指令EXTERN声明
* 子程序在代码段，与主程序文件采用相同的存储模型
* 没有开始执行和结束执行点，但有汇编结束语句
* 处理好子程序与主程序之间的参数传递问题

子程序源文件汇编形成目标模块OBJ文件

连接时输入子程序目标模块文件名

```assembly
;定义标识符的模块使用
public 标识符[,标识符...]
;调用标识符的模块使用
extern 标识符:类型[,标识符:类型...]
```

```assembly
;文件名：eg.asm,主程序
...
temp dword ? ;共享变量定义
extern rdhd:near,dphd:near,write:near ;外部子程序
public temp ;变量共用
	.code ;代码段，组程序
	...
	end start
```

 

### 子程序库和库文件包含

子程序库是子程序模块的集合，便于统一管理子程序



## 宏汇编

宏是具有宏名的一段汇编语句序列

宏需要先使用MACRO/ENDM伪指令进行定义

然后在程序中使用宏名（带参数）进行宏调用

源程序进行汇编时候

* 宏名被汇编程序用宏定义的
* 代码序列替代，实现宏展开

> 宏定义
>
> 宏名 macro [形参表]
>
> ​		... ;宏定义体
>
> ​		endm

```assembly
;宏定义
WirteString macro msg
						push eax
						lea eax,msg
						call dispmsg
						pop eax
						endm
```

```assembly
;宏调用（宏指令）
;写上宏名，和它所需要的参数
WriteString msg1;可以一样也可以不一样msg
```

```assembly
;宏展开
push eax
lea eax,msg1
call dispmsg
pop eax
```

### 宏汇编的特点

宏需要先定义后使用，且不必在任何段中

* 常书写于源程序开始位置
* 常用的宏定义可以单独写成一个宏定义文件

宏定义中更改了寄存器内容，最好进行保护和恢复

宏定义的参数灵活，宏定义允许嵌套和递归调用

宏调用不需要控制的转移与返回

* 宏调用将相应的语句序列复制到宏指令的位置
* 宏展开被嵌入源程序，成为一体

类似于子程序



### 宏与子程序：简化程序

宏仅是源程序级的简化

* 宏调用在汇编时进行程序语句的展开，不需要返回
* 不减小目标程序，执行速度不变

子程序不仅简化源程序，还是目标程序级的简化

* 子程序调用在执行时由CALL指令转向、RET指令返回
* 形成的目标代码较短，执行速度减慢







# 一些实例

## 数据定义综合应用

```assembly
;数据段
bvar DB 16
wvar DW 4*3
dvar DD 4294967295 ;=2^32-1
qvar DQ ?
		 DB 1,2,3,4,5
tvar DT 2345
abc  DB 'a','b','c'
msg  DB 'Hello',13,10,'$'
bbuf DB 12 DUP('month')
dbuf DD 25 DUP(?)
CALLDOS EQU <int 21h>
;代码段
mov bl,bvar
mov ax,word ptr dvar[0]
mov dx,word ptr dvar[2] ;取双字到DX.AX
mov dx,offset msg
mov ah,09h
CALLDOS
```



## 数据复制和显示

```assembly
      ;数据段
      source db 33h,34h,35h,36h ;定义4个字符数据
      target db 80 dup(?) ;分配数据空间4x20=80
      ;代码段
      mov si, offset source ;SI->源缓冲区
      mov di, offset target ;DI->目的缓冲区
      mov cx, 80 ;CX->字符个数
again1: mov al,[si] ;从原缓冲区取一个字符
				mov [di],al ;传送到目的缓冲区
				inc si ;指向下一个字符位置
				inc di
				loop again2 ;重复传送80次
				mov di,0
again2: mov dl,target[di] ;从目的缓冲区取字符
				mov ah,2
				int 21h ;显示
				inc di
				cmp di,80
				jb again2
```



## 一些结构的实例

```assembly
;查表法，实现十六进制数转换为ASCII码显示
;数据段
HEX db 4bh
ASCII db 30h,31h,32h,33h,34h,35h
			db 36h,37h,38h,39h ;0~9的ASCII码
			db 41h,42h,43h,44h,45h,46h ;A~F的ASCII码
			;任一设定了一个待转换的一位16进制数
			;代码段
			mov bx,offset ASCII ;BX指向ASCII码表
			mov al,HEX ;AL取得一位16进制数，正是ASCII码表中位移
			mov cl,4 ;什么操作
			sar al,cl ;高4位移入低4位
			xlat ;换码：AL <- DS:[BX+AL]
			mov dl,al ;入口参数：DL <- AL
			mov ah,2 ;02号DOS功能调用
			int 21h ;显示数据高位
			mov al,HEX ;取数据，显示低4位
			and al,0fh ;只有低4位有效，高4位清0
			xlat ;换码：AL <- DS:[BX+AL]
			mov dl,al ;入口参数：DL <- AL
			mov ah,2 ;02号DOS功能调用
			int 21h
```



### 单分支程序设计

条件成立跳转，否则顺序执行分支与具体；注意选择正确的条件转移指令和转移目标地址

#### 求绝对值

```assembly
		cmp ax,0 ;cmp指令影响的符号位
		jns nonneg ;分支条件：AX>=0
		neg ax ;条件不满足，求补
nonneg:mov result,ax ;条件满足
```

#### 无符号数除以2

```assembly
		test ax,01h ;测试AX最低位
		jz even ;最低位为0：AX为偶数
		add ax,1 ;最低位为1：AX为奇数，需要加1
even: rcr ax,1 ;AX <- AX/2
;如果采用SHR指令，无法处理AX=FFFFH的特殊情况，那时候CF=1
```

### 双分支程序结构

条件成立跳转执行第二个分支语句体，否则顺序执行第一个分支语句体

第一个分支语句体后一定要有一个JMP跳转到第二个之后

#### 显示BX最高位

```assembly
		shl bx,1 ;BX最高位移入CF
		jc one ;CF=1，即最高位为1，转移
		mov dl,"0" ;CF = 1，最高位为0，DL<-'0'
		jmp two ;一定要跳
one: mov dl ,'1';DL <- '1'
two: mov ah ,2
		int 21h ;显示
```

也可以改成单分支程序

```assembly
		mov dl,'0' ;DL <- '0'
		shl bx,1 ;bx最高位移入CF
		jnc two ;CF=0，最高位为0，转移
		mov dl,'1';CF=1,最高位为1，DL<-'1'
two: mov ah,2
		 int 21 ;显示
```

#### 判断有无实根

```assembly
;data segment
_a db ?
_b db ?
_c db ?
tag db ?
		mov al,_b
		imul al
		mov bx,ax ;bx中为b^2
		mov al,_a
		cmp bx,ax ;比较两者大小
		jge yes ;条件满足?
		mov tag,0 ;第一分支体：条件不满足。tag <- 0
		jmp done ;跳过第二个分支体
yes:mov tag,1 ;第二个分支体：条件满足，tag <- 1
done:
```



### 多分支

```assembly
or ah,ah ;cmp ah,0
jz function0 ;ah=0,转向function0
dec ah ;cmp ah,1
jz function1 ;ah=1,转向function1
dec ah ;cmp ah,2
jz function2 ;aj=2,转向function2
```

#### 地址表形成多分支

需要在数据段事先安排一个按顺序排列的转移地址表

输入的数字作为偏移量

关键是间接寻址方式JMP指令

```assembly
;data segment
msg db "Input number(1~8):",0dh,0ah,'$'
msg1 db "Chapter 1 : ...",0dh,0ah,'$'
msg2 db "Chapter 2 : ...",0dh,0ah,'$'
			...
msg8 db "Chapter 8 : ...",0dh,0ah,'$'
table dw disp1,disp2,disp3,disp4 ;disp1等同于 offset disp1
			dw disp5,disp6,disp7,disp8 ;取得各个标号的偏移地址
start1: mov dx,offset msg ;提示输入数字
			  mov ah,9
			  int 21h
			  mov ah,1 ;等待按键
			  int 21h
			  cmp al,"1" ;数字小于1?
			  jb start1
			  cmp al,"8" ;数字大于8?
			  ja start1
			  and ax,000fh ;将ASCII码转换成数值
			  dec ax
			  shl ax,1 ;why ax <- ax+ax?
			  mov bx,ax
			  jmp table[bx];也可call table[bx]
start2: mov ah,9
				int 21h
				.exit 0
disp1: mov dx, offset msg1;处理程序1
			 jmp start2 ;对应修改为ret
			 ... 
```

